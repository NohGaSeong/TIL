# 복잡도
## 복잡도란
- 복잡도는 알고리즘의 성능을 나타내는 척도. 시간 복잡도와 공간 복잡도로 나눌 수 있음.
- 시간 복잡도 : 특정한 크기의 입력에 대하여 알고리즘이 얼마나 오래 걸리는지를 의미
- 공간 복잡도 : 특정한 크기의 입력에 대하여 알고리즘이 얼마나 많은 메모리를 차지하는지를 의미
- 동일한 기능을 수행하는 알고리즘이 있다면 일반적으로 복잡도가 낮을수록 좋은 알고리즘. 복잡도를 측정함으로써 아래의 2가지를 계산할 수 있다.
- 시간 복잡도 : 알고리즘을 위해 필요한 연산의 횟수
- 공간 복잡도 : 알고리즘을 위해 필요한 메모리의 양

## 시간 복잡도
- 알고리즘 문제를 풀 때 단순히 복잡도 라고 하면 보통은 시간 복잡도를 의미함.
- 시간 복잡도를 표현할 때는 빅오 표기법을 사용함. (빅오 표기법을 간단히 정의하면 가장 빠르게 증가하는 항만을 고려하는 표기법)
- 소스코드에서 가장 영향력이 큰 부분은 N에 비례하는 연산을 수행하는 반복문 부분이므로 시간 복잡도를 O(N)이라고 표기
```.py
a = 5
b = 7
print(a + b)
```
- 이 소스의 연산 횟수는 1이다. 단순히 더하기 연산 한 번이 수행되기 때문. 이는 상수 연산이므로 시간복잡도는 O(1) 로 표기할 수 있다.
```.py
array = [3, 5, 1, 2, 4] #5개의 데이터(N = 5)

for i in array:
  for j in array:
    temp = i * j
    print(temp)
```
- 이 소스는 데이터의 개수가 N개일때, O(N2)의 시간복잡도를 가진다. 빅오 표기법의 표는 아래와 같다.<br>
![image](https://user-images.githubusercontent.com/82383294/214505871-b4329f5c-c532-49d7-96f3-a2f24a6e3ba6.png)

## 공간 복잡도
- 공간 복잡도를 표기할 때도 시간 복잡도를 표기했던 것처럼 빅오 표기법을 이용.
- 다만 앞서 시간 복잡도에서 1초라는 절대적인 제한이 있던 것처럼, 메모리 사용량에도 절대적인 제한이 있다. 일반적으로 메모리 사용량 기분은 MB단위로 제시됨.
- 코딩 테스트의 문제는 대부분 리스트를 사용해서 풀어야한다. 대부분의 문제는 다수의 데이터에 대한 효율적인 처리를 요구하기 때문이다.
- int a[1000] : 4KB
- int a[1000000] : 4MB
- int a[2000][2000] : 16MB
- 코딩테스트에서는 보통 메모리 사용량을 128~512MB 정도로 제한한다. 다시 말해 일반적인 경우 데이터의 개수가 1000만 단위가 넘어가지 않도록 알고리즘 설계를 해야한다는 의미이다.

## 시간과 메모리 측정
- 파이썬에서는 플고그램 수행 시간과 메모리 사용량을 측정할 수 있다. 알고리즘을 공부하는 과정에서 시간을 측정하는 작업을 굉장히 많이 사용한다.
- 실질적으로 알고리즘의 소요 시간을 확인해야 자신이 제대로 알고리즘을 작성하고 있는지 체크할 수 있기 때문이다. 다시 말해 실제 프로그램의 수행 시간을 측정하는 것은 알고리즘의 효율성을 측정하는 가장 기본적인 방법이다.
- 특정한 프로그램의 수행시간을 측정하는 소스코드 에시는 다음과 같다.
```.py
import time
start_time = time.time()

end_time = time.time()
print("time : ", end_time - start_time)
```
- 선택 정렬과 기본 정렬 라이브러리의 수행 시간을 비교해보자
```.py
from random import randint
import time

array = []
for _ in range(10000):
  array.append(randint(1, 100))
  
start_time = time.time()

for i in range(len(array)):
  min_index = i
  for j in range(i + 1, len(array)):
    if array[min_index] > array[j]:
      min_index = j
  array[i], array[min_index] = array[min_index], array[i]
  
end_time = time.time()
print("선택 정렬 성능 측정:", end_time - start_time)

array = []
for _ in range(10000):
  array.append(randint(1, 100))
  
start_time = time.time()

array.sort()

end_time = time.time()
print("기본 정렬 라이브러리 성능 측정:", end_time - start_time)
```
- 선택 정렬은 30초가 넘게 걸리고, 기본 정렬 라이브러리는 1초도 걸리지 않았다. 이처럼 자신이 설계한 알고리즘의 성능을 실제로 확인하기 위해서, 시간 측정 라이브러리를 사용해보는 습관을 기르는 것이 좋다.
