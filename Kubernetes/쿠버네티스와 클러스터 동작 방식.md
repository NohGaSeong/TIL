## 쿠버네티스가 왜 필요할까? 
- 배포해야 할 마이크로서비스가 수백 개인 경우에 사람이 처리할 수 있을까?
- 수많은 마이크로 서비스를 여러 서버에 효율적으로 배치하는 것은 어렵다.
- 여러 서버와 마이크로 서비스 배포 조합 수를 사람이 계산할 수 없음 (충분한 리소스 할당 -> 리소스 낭비, 비용 발생)
- 간단한 재시작만으로 해결되는 경우에도 복구시간이 오래 걸림.

## 쿠버네티스는 다음을 제공한다.
### 자동화된 빈 패킹
컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공한다. 각 컨테이너가 필요로 하는 cpu 와 메모리를 쿠버네티스에게 지시한다. 쿠버네티스는 컨테이너를 노드에 맞춰서 리소르를 가장 잘 사용할 수 있도록 해준다.

### 자동화된 복구
쿠버네티스는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, '사용자 정의 상태 검사'에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지 않는다.

### 자동화된 롤아웃과 롤백
쿠버네티스를 사용하여 배포된 컨테이너의 원하는 상태를 서술할 수 있으며 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있다. 예를 들어 쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용할 수 있다.

(중략)

## 그래서 쿠버네티스?
- Borg, Omega 와 달리 오픈 소스
- 구글 퍼블릭 클라우드 인프라 사업을 성장시키기 위해 설계하고 개발함
- Omega 처럼 리소스 변경 사항을 저장하기 위한 공유 영구 저장소가 있지만, Omega는 이 저장소를 신뢰할 수 있는 구성요소들이 직접 접근할 수 있도록 개방한 것과 달리, 쿠버네티스는 더 높ㅇ른 수준의 추상화를 위해 REST API를 통해서만 접근할 수 있도록 바꾸었다.
- 쿠버네티스가 클러스터에서 실행되는 애플리케이션을 개발하는 개발자의 경험에 더 중점을 두고 개발했다는 것.
- 주요 설계 목표는 컨테이너로 향상된 리소스 활용의 이점을 누리면서도 복잡한 분산 시스템을 쉽게 배포하고 관리할 수 있게 만드는 것.

## 쿠버네티스의 의미
- 쿠버네티스 = 조타수 : 주어진 명령을 핸들에 반복 실행해야한다.

쿠버네티스는 여러 개의 컨테이너화된 애플리케이션을 여러 서버에 자동으로 배포, 스케일링 및 관리해주는 오픈소스 시스템.

## 클러스터
클러스터 : 여러 개의 서버를 하나로 묶은 집합, 하나의 서버처럼 동작
쿠버네티스 클러스터 : 애플리케이션 컨테이너를 배포하기 위한 서버 집합

### Master Node의 Control Plane 
클러스터의 상태를 저장하고 관리
- etcd(key-value data store) : 클러스터에 배포된 애플리케이션 실행 정보를 저장
- API Server : 클러스터 상재 조회, 변경을 위한 API 인터페이스 제공
- Schduler
- Controller managers

### Worker 노드
컨테이너 실행을 담당
- Kubelet, Container Runtime(Docker, ... )
- kube-proxy

## 쿠버네티스에 애플리케이션 컨테이너를 배포한다란?
쿠버네티스 오브젝트 Manifest 파일을 작성해서 마스터 노드에 잇는 API Server에게 요청을 보내는 행위

Manifest 파일?
- 쿠버네티스 오브젝트를 생성하기 위한 필수 정보
- "일을 시키기 위한 지시서"

